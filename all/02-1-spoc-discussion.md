#lec 3 SPOC Discussion

## 第三讲 启动、中断、异常和系统调用-思考题

## 3.1 BIOS
 1. 比较UEFI和BIOS的区别。
 1. 描述PXE的大致启动流程。

> UEFI和BIOS区别

|/|UEFI | BIOS |
|-|-|-|
|开机模式|保护模式 | 16位实模式
|开机时寻址空间 | | 16bit，$2^{16} = 64KB$
|语言 | C 语言 | 组合语言 
|扩充方式 | 载入驱动程序 | 结合中断向量
|可扩展性 | 好 | 较差
|输出 | 用EFI Byte Code（EFI字节代码）编写而成的，需要解释 | 由直接运行在CPU上的代码组成 

流程对比

|步骤 | UEFI | BIOS
|-|-|-
|1 | 系统开机 - 上电自检（Power On Self Test 或 POST）。|系统开机 - 上电自检（Power On Self Test 或 POST）。
|2 |UEFI 固件被加载，并由它初始化启动要用的硬件。 | POST过后初始化用于启动的硬件（磁盘、键盘控制器等）。
|3 | 固件读取其引导管理器以确定从何处（比如，从哪个硬盘及分区）加载哪个 UEFI 应用。| BIOS会运行BIOS磁盘启动顺序中第一个磁盘的首440bytes（MBR启动代码区域）内的代码。
|4| 固件按照引导管理器中的启动项目，加载UEFI 应用。| 启动引导代码从BIOS获得控制权，然后引导启动下一阶段的代码（如果有的话）（一般是系统的启动引导代码）。
|5|已启动的 UEFI 应用还可以启动其他应用（对应于 UEFI shell 或 rEFInd 之类的引导管理器的情况）或者启动内核及initramfs（对应于GRUB之类引导器的情况），这取决于 UEFI 应用的配置。| 再次被启动的代码（二阶段代码）（即启动引导）会查阅支持和配置文件。
|6 | / | 根据配置文件中的信息，启动引导程序会将内核和initramfs文件载入系统的RAM中，然后开始启动内核。

> PXE ，网络启动，大致启动流程 
1. POST
2. 发送一个动态获得IP地址的广播包（请求FIND帧）到网络上。
3. DHCP服务器在收到该广播包后，发送给客户端分配IP地址的DHCP回应包。内容包括客户端的IP地址，TFTP服务器的IP地址（DHCP服务器的066选项），预设通讯通道，及开机启动文件（DHCP服务器的067选项）。该文件应该是一种由PXE启动规范规定的固定格式的可执行文. XP正常启动时显示多重启动菜单之前的启动代码。 
4. 客户面收到DHCP回应后，则会响应一个FRAME，以请求传送启动文件。之后，服务端将和客户机再进行一系列应答，以决定启动的一些参数。
5. 客户端通过TFTP通讯协议从服务器下载开机启动文件。启动文件接收完成后，将控制权转交给启动块，完成PXE启动。客户端通过这个开机影像文件开机，这个开机文件可以只是单纯的开机程式也可以是操作系统。如果是用3Com Boot Image Editor编辑的启动文件，系统将根据PXE文件中的代码决定是显示选择菜单还是直接下载预设的镜像文件启动电脑。
接下来的工作就由相应的镜像文件来完成了。
> 参考资料：https://www.microsoft.com/resources/documentation/WindowsServ/2003/all/ADS/en-us/nbs_boot_policy_overview.mspx?mfr=true


## 3.2 系统启动流程
 1. 了解NTLDR的启动流程。
 
```
 1. NTLDR把计算机的微处理器从实模式转换为32位平面内存模式
 2. NTLDR执行适当的小型文件系统驱动程序并加载Boot.ini文件
 3. NTLDR通过Boot.ini文件获得要启动的操作系统
 4. NTLDR进行硬件检测，检测结束后进行配置选择
```
 1. 了解GRUB的启动流程。

```
 1. 装载第二引导装载程序
 2. 显示启动菜单和提供用户交互接口，并根据用户选择或默认配置加载操作系统内核
 3. 根据grub.conf显示启动菜单，提供同用户交互界面
 4. 根据用户选择或默认配置和grub.conf的内核配置加载相应的内核程序，把控制权交给内核程序
```
 1. 比较NTLDR和GRUB的功能有差异。

```
 1.NTLDR只能引导windows系统，只能安装在硬盘
 2.GRUB可以引导任意系统，可以安装在U盘，硬盘，光盘等
 
```
 1. 了解u-boot的功能。

```
* 系统引导支持NFS挂载、RAMDISK(压缩或非压缩)形式的根文件系统；支持NFS挂载、从FLASH中引导压缩或非压缩系统内核；
* 基本辅助功能强大的操作系统接口功能；可灵活设置、传递多个关键参数给操作系统，适合系统在不同开发阶段的调试要求与产品发布，尤以Linux支持最为强劲；支持目标板环境参数多种存储方式，如FLASH、NVRAM、EEPROM；
* CRC32校验可校验FLASH中内核、RAMDISK镜像文件是否完好；
* 设备驱动串口、SDRAM、FLASH、以太网、LCD、NVRAM、EEPROM、键盘、USB、PCMCIA、PCI、RTC等驱动支持；
* 上电自检功能SDRAM、FLASH大小自动检测；SDRAM故障检测；CPU型号；
* 特殊功能XIP内核引导；
```

## 3.3 中断、异常和系统调用比较
 1. 举例说明Linux中有哪些中断，哪些异常？
 1. Linux的系统调用有哪些？大致的功能分类有哪些？  (w2l1)

```
  + 采分点：说明了Linux的大致数量（上百个），说明了Linux系统调用的主要分类（文件操作，进程管理，内存管理等）
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 ```
 
 1. 以ucore lab8的answer为例，uCore的系统调用有哪些？大致的功能分类有哪些？(w2l1)
 
> Linux中把中断描述符分为五类：

| 门|功能 |
|-|-|
|中断门（interrupt gate）| 用户态的进程不能访问Intel中断门（门的DPL字段为0）。所有的Linux中断处理程序都通过中断门激活，并全部限制在内核态。
|系统门（system gate）|用户态的进程可以访问Intel陷阱门（门的DPL字段为3）。通过系统门来激活三个Linux异常处理程序|
|系统中断门（system interrupt gate）| 能够被用户态进程访问的Intel中断门（门的DPL字段为3）。与向量3相关的异常处理程序是由系统中断门激活的
|陷阱门（trap gate）| 用户态的进程不能访问的一个Intel陷阱门（门的DPL字段为0）。大部分Linux异常处理程序都通过陷阱门来激活。
|任务门（task gate）| 不能被用户态进程访问的Intel任务门（门的DPL字段为0）。Linux对“Double fault”异常的处理程序是由任务门激活的。|
 
 > - 查看全部中断，可以查看linux 的中断向量表。中断举例： 时钟中断，键盘输入中断等。
> - 异常举例：除零错，page fault 等

 ```
  + 采分点：说明了ucore的大致数量（二十几个），说明了ucore系统调用的主要分类（文件操作，进程管理，内存管理等）
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 ```
 > - 有二十几个系统调用
 > - 提供文件读写，内存管理等服务

 
## 3.4 linux系统调用分析
 1. 通过分析[lab1_ex0](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab1/lab1-ex0.md)了解Linux应用的系统调用编写和含义。(w2l1)
 

 ```
  + 采分点：说明了objdump，nm，file的大致用途，说明了系统调用的具体含义
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 
 ```
 
 1. 通过调试[lab1_ex1](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab1/lab1-ex1.md)了解Linux应用的系统调用执行过程。(w2l1)
 

 ```
  + 采分点：说明了strace的大致用途，说明了系统调用的具体执行过程（包括应用，CPU硬件，操作系统的执行过程）
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 ```
 
## 3.5 ucore系统调用分析
 1. ucore的系统调用中参数传递代码分析。
 1. ucore的系统调用中返回结果的传递代码分析。
 1. 以ucore lab8的answer为例，分析ucore 应用的系统调用编写和含义。
 1. 以ucore lab8的answer为例，尝试修改并运行ucore OS kernel代码，使其具有类似Linux应用工具`strace`的功能，即能够显示出应用程序发出的系统调用，从而可以分析ucore应用的系统调用执行过程。
 
## 3.6 请分析函数调用和系统调用的区别
 1. 请从代码编写和执行过程来说明。
   1. 说明`int`、`iret`、`call`和`ret`的指令准确功能
 
